#include <StateSpaceControl.h>

/*
 * This example shows how StateSpaceControl can be used to control the position of a cart while it balances a pole attached to it using a passive rotational joint.
 * The model being used comes from this analysis: http://ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&section=SystemModeling
 * which defines the state as: x = [cart_position, cart_velocity, stick_angle, stick_angular_rate]^T . It's assumed that the cart position and the stick angle are directly observable 
 * and the rest of the state is recovered using an estimator.
 */

const float pi = 3.141592654;
const float Mg = 0.607;   
const float Hg = 0.11;   
const float Mc = 3.04;    
const float Hc = 0.096;   
const float Ic = 0.04375;
const float Ir = 0.000225;
const float Ip = 0.000340;
const float w  = 140*2*pi;
const float g  = 9.8;     
const float Kt = 56;

const float Vnl = 14;     
const float Inl = 0.07;   
const float Wnl = 6500;   
const float L = 0.67;     
const float R = 18.45;    
const float Bm = 0.11;    
const float Ke = Vnl/((Wnl/60)*2*pi); 
const float Km = Ke;  
const float J = 10*10^(-7);

const float theta0 = 0;
const float alpha0 = 0;

// Start by defining a state space model, This particular model describes the cart pole system but you can define any model by just declaring a Model object and then
// filling out the state matrices. See Model.h for examples on how to do this (and feel free to PR to add your own!).
GyroModel model(Mc,Mg,Hg,Hc,Ic,Ip,Ir,w,g,L,R,Bm,Km,Ke,Kt);

// Next define a state space controller. The cart pole model uses 4 states, 1 input and 2 outputs so we'll need to specify these inside the <> brackets when declaring the controller.
// The controller also uses state estimation so to enable this, supply true as the fourth template parameter, like so:
StateSpaceController<5,1,2,true> controller(model);

// Lastly, since the controller isn't controlling a cart pole, we'll need to simulate one to show how the controller works. The Simulation class handles this by accepting 
// the control inputs generated by the controller (u) and returning observations from the motor (y).
Simulation<5,1,2> sim(model);

Matrix<2> y;
const float dt = 0.01;
long oldT;

void setup()
{
  Serial.begin(115200);

  // To parameterise the controller, we'll need to fill out the control law matrix K, and the estimator matrix L.
  // K defines feedback gains which are loosely similar to PID gains while L is equivilent to the Kalman Gain of a Kalman Filter.
  // If you're wondering where these numbers came from, head over to TuneThoseGains.ipynb
  controller.K << 81.12, 7.53, -7.07, 0.044, 6.83;
  controller.L << 90.0164  , -0.6545 ,
				   51.6925 ,  -9.1942,
				   -0.6545 ,  90.8036,
				 -109.1496 , 122.8630,
					1.3180 ,   8.7319;

  // Once the system and gain matrices are filled in, the controller needs to be initialised so that it can precalculate Nbar
  controller.initialise();

  // Try to bring the cart to rest at 3.5m from it's home position
  controller.r << 0.0, 0.0;

  // Let's also set some initial conditions on the simulation so that the controller's estimator has to work for it
  sim.x << -10*pi/180, 0.0, 0.0, 0.0, 0.0;
}

// Now we can start the control loop
void loop()
{
  // Firstly generate some measurements from the simulator. Since this model assumes that only part of the state can be can be directly observed,
  // y contains two elements containing cart position and stick angle. If we were controlling an actual cart pole, these observations would come, for example,
  // from a set of encoders attached to the cart's wheels and stick joint.

  oldT = micros();
  y = sim.step(controller.u, dt);
  int dTime1 = micros() - oldT;
  

  // Now update the state space controller, which causes it to update its u member (the control input). When controlling an actual system, the updated control input
  // would be used to command the cart's motor driver or similar.
  oldT = micros();
  controller.update(y, dt);
  int dTime2 = micros() - oldT;

  // Print the current system output to serial. If the controller is doing its job properly then y should settle at whatever r was set to after a short transient.
  Serial << "theta = " << y(0)*180/pi << " ; alpha = " << y(1)*180/pi << " ; ns1 = " << dTime1<< " ; ns2 = " << dTime2<< '\n';

  delay(dt * 1000);
}